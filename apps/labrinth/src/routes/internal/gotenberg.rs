use std::fmt;

use actix_web::{HttpMessage, error::ParseError, http::header, post, web};
use dashmap::DashMap;
use eyre::eyre;
use serde::Deserialize;
use thiserror::Error;
use tokio::sync::oneshot;
use tracing::trace;

use crate::routes::ApiError;
use crate::util::error::Context;
use crate::util::gotenberg::{
    GeneratedPdfType, MODRINTH_GENERATED_PDF_TYPE, MODRINTH_PAYMENT_ID,
};
use crate::util::guards::internal_network_guard;

/// Queue for document generation requests which have been submitted to
/// Gotenberg and are awaiting completion.
#[derive(Debug, Default)]
pub struct GotenbergQueue {
    pub(crate) pending: DashMap<
        ModrinthPaymentId,
        oneshot::Sender<Result<GotenbergDocument, ErrorBody>>,
    >,
}

/// Document generated by Gotenberg and returned to us.
#[derive(Debug)]
pub struct GotenbergDocument {
    /// Body of the document.
    pub body: web::Bytes,
}

pub fn config(cfg: &mut actix_web::web::ServiceConfig) {
    cfg.service(success_callback).service(error_callback);
}

#[post("/gotenberg/success", guard = "internal_network_guard")]
pub async fn success_callback(
    web::Header(header::ContentDisposition {
        disposition,
        parameters: disposition_parameters,
    }): web::Header<header::ContentDisposition>,
    web::Header(GotenbergTrace(trace)): web::Header<GotenbergTrace>,
    web::Header(ModrinthGeneratedPdfType(r#type)): web::Header<
        ModrinthGeneratedPdfType,
    >,
    maybe_payment_id: Option<web::Header<ModrinthPaymentId>>,
    body: web::Bytes,
    queue: web::Data<GotenbergQueue>,
) -> Result<(), ApiError> {
    trace!(
        %trace,
        %disposition,
        ?disposition_parameters,
        r#type = r#type.as_str(),
        ?maybe_payment_id,
        body.len = body.len(),
        "Received Gotenberg generated PDF"
    );

    let payment_id =
        maybe_payment_id.wrap_request_err("no payment ID for document")?;

    let (_, pending) = queue
        .pending
        .remove(&payment_id)
        .wrap_internal_err_with(|| {
            eyre!(
                "got a document for {payment_id:?}, but there is no pending request for this - \
                document submitted twice?"
            )
        })?;
    _ = pending.send(Ok(GotenbergDocument { body }));

    Ok(())
}

#[allow(dead_code)]
#[derive(Debug, Clone, Deserialize, Error)]
pub struct ErrorBody {
    pub status: Option<String>,
    pub message: Option<String>,
}

impl fmt::Display for ErrorBody {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match (&self.status, &self.message) {
            (None, None) => write!(f, "(unknown error)"),
            (Some(status), None) => write!(f, "status {status}"),
            (None, Some(message)) => write!(f, "(no status) {message}"),
            (Some(status), Some(message)) => {
                write!(f, "status {status}: {message}")
            }
        }
    }
}

#[post("/gotenberg/error", guard = "internal_network_guard")]
pub async fn error_callback(
    web::Header(GotenbergTrace(trace)): web::Header<GotenbergTrace>,
    web::Header(ModrinthGeneratedPdfType(r#type)): web::Header<
        ModrinthGeneratedPdfType,
    >,
    maybe_payment_id: Option<web::Header<ModrinthPaymentId>>,
    web::Json(error_body): web::Json<ErrorBody>,
    queue: web::Data<GotenbergQueue>,
) -> Result<(), ApiError> {
    trace!(
        %trace,
        r#type = r#type.as_str(),
        ?maybe_payment_id,
        ?error_body,
        "Received Gotenberg error webhook"
    );

    let payment_id =
        maybe_payment_id.wrap_request_err("no payment ID for document")?;

    let (_, pending) = queue.pending.remove(&payment_id)
            .wrap_internal_err_with(|| eyre!("got a document for {payment_id:?}, but there is no pending request for this - document submitted twice?"))?;
    _ = pending.send(Err(error_body));

    Ok(())
}

#[derive(Debug)]
struct GotenbergTrace(String);

impl header::TryIntoHeaderValue for GotenbergTrace {
    type Error = header::InvalidHeaderValue;

    fn try_into_value(self) -> Result<header::HeaderValue, Self::Error> {
        header::HeaderValue::from_str(&self.0)
    }
}

impl header::Header for GotenbergTrace {
    fn name() -> header::HeaderName {
        header::HeaderName::from_static("gotenberg-trace")
    }

    fn parse<M: HttpMessage>(m: &M) -> Result<Self, ParseError> {
        m.headers()
            .get(Self::name())
            .ok_or(ParseError::Header)?
            .to_str()
            .map_err(|_| ParseError::Header)
            .map(ToOwned::to_owned)
            .map(GotenbergTrace)
    }
}

#[derive(Debug)]
struct ModrinthGeneratedPdfType(GeneratedPdfType);

impl header::TryIntoHeaderValue for ModrinthGeneratedPdfType {
    type Error = header::InvalidHeaderValue;

    fn try_into_value(self) -> Result<header::HeaderValue, Self::Error> {
        header::HeaderValue::from_str(self.0.as_str())
    }
}

impl header::Header for ModrinthGeneratedPdfType {
    fn name() -> header::HeaderName {
        MODRINTH_GENERATED_PDF_TYPE
    }

    fn parse<M: HttpMessage>(m: &M) -> Result<Self, ParseError> {
        m.headers()
            .get(Self::name())
            .ok_or(ParseError::Header)?
            .to_str()
            .map_err(|_| ParseError::Header)?
            .parse()
            .map_err(|_| ParseError::Header)
            .map(ModrinthGeneratedPdfType)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModrinthPaymentId(pub String);

impl header::TryIntoHeaderValue for ModrinthPaymentId {
    type Error = header::InvalidHeaderValue;

    fn try_into_value(self) -> Result<header::HeaderValue, Self::Error> {
        header::HeaderValue::from_str(&self.0)
    }
}

impl header::Header for ModrinthPaymentId {
    fn name() -> header::HeaderName {
        MODRINTH_PAYMENT_ID
    }

    fn parse<M: HttpMessage>(m: &M) -> Result<Self, ParseError> {
        m.headers()
            .get(Self::name())
            .ok_or(ParseError::Header)?
            .to_str()
            .map_err(|_| ParseError::Header)
            .map(ToOwned::to_owned)
            .map(ModrinthPaymentId)
    }
}
